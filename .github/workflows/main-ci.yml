name: Main CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - development
        - production

env:
  CARGO_TERM_COLOR: always
  APPWRITE_PROJECT_ID: intrada-dev
  APPWRITE_DATABASE_ID: intrada_db
  APPWRITE_DATABASE_NAME: "Intrada Database"

# Prevent concurrent runs on the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Job to determine what changed and what needs to be built
  changes:
    runs-on: ubuntu-latest
    outputs:
      rust: ${{ steps.changes.outputs.rust }}
      ios: ${{ steps.changes.outputs.ios }}
      web: ${{ steps.changes.outputs.web }}
      appwrite: ${{ steps.changes.outputs.appwrite }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            rust:
              - 'shared/**'
              - 'infrastructure/**'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'rust-toolchain.toml'
            ios:
              - 'iOS/**'
              - 'shared/**'
              - '.github/workflows/main-ci.yml'
            web:
              - 'web-leptos/**'
              - 'shared/**'
              - '.github/workflows/main-ci.yml'
            appwrite:
              - 'infrastructure/**'
              - 'appwrite.json'
              - 'scripts/setup-appwrite-complete.sh'

  # Unified build job that compiles everything needed
  build-artifacts:
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.rust == 'true' || needs.changes.outputs.web == 'true' || needs.changes.outputs.appwrite == 'true'
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          targets: 'wasm32-unknown-unknown'
          
      - name: Generate cache key
        id: cache-key
        run: |
          key="build-artifacts-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}-v2"
          echo "key=$key" >> $GITHUB_OUTPUT
          
      - name: Cache build artifacts
        uses: actions/cache@v4
        id: cache-artifacts
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
            shared/target/
            web-leptos/target/
            infrastructure/target/
          key: ${{ steps.cache-key.outputs.key }}
          restore-keys: |
            build-artifacts-${{ runner.os }}-v2
            
      - name: Build all artifacts
        if: steps.cache-artifacts.outputs.cache-hit != 'true'
        run: |
          # Fetch all dependencies first
          cargo fetch --locked
          
          # Build infrastructure CLI in release mode (for appwrite deployment)
          cd infrastructure
          cargo build --bin appwrite_cli --features cli --release
          
          # Build shared library for all targets
          cd ../shared
          cargo build --lib --release
          cargo build --lib --release --target wasm32-unknown-unknown
          
          # Build web app dependencies
          cd ../web-leptos
          cargo build --lib --release --target wasm32-unknown-unknown
          
      - name: Ensure CLI binary exists
        run: |
          if [[ ! -f "target/release/appwrite_cli" ]]; then
            echo "CLI binary not found, building it..."
            cd infrastructure
            cargo build --bin appwrite_cli --features cli --release
          else
            echo "CLI binary found at target/release/appwrite_cli"
          fi
          
      - name: Upload CLI binary
        uses: actions/upload-artifact@v4
        with:
          name: appwrite-cli
          path: target/release/appwrite_cli
          retention-days: 1

  # Basic Rust checks (formatting, clippy, tests)
  rust-checks:
    runs-on: ubuntu-latest
    needs: [changes, build-artifacts]
    if: needs.changes.outputs.rust == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Rust
        uses: ./.github/actions/setup-rust
          
      - name: Restore build artifacts cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
            shared/target/
            infrastructure/target/
          key: ${{ needs.build-artifacts.outputs.cache-key }}
          restore-keys: |
            build-artifacts-${{ runner.os }}-v2
            
      - name: Check code formatting
        run: cargo fmt --all -- --check
        
      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
        
      - name: Run tests
        run: |
          cargo test --workspace
          cd infrastructure && cargo test --features cli

  # iOS build job with optimized caching
  ios-build:
    runs-on: macos-15
    needs: [changes, build-artifacts]
    if: needs.changes.outputs.ios == 'true'
    env:
      DEVELOPER_DIR: /Applications/Xcode_16.0.app/Contents/Developer
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.0'

      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          targets: 'aarch64-apple-ios-sim,x86_64-apple-ios'
          cache-suffix: '-ios'

      - name: Cache iOS build artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            shared/target/aarch64-apple-ios-sim/
            shared/target/x86_64-apple-ios/
            shared/target/debug/
          key: ios-build-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}-v1
          restore-keys: |
            ios-build-${{ runner.os }}-v1

      - name: Cache cargo tools
        uses: actions/cache@v4
        id: cache-cargo-tools
        with:
          path: ~/.cargo/bin
          key: cargo-tools-${{ runner.os }}-v1
          restore-keys: |
            cargo-tools-${{ runner.os }}-
            
      - name: Install cargo-swift
        if: steps.cache-cargo-tools.outputs.cache-hit != 'true'
        run: |
          if ! command -v cargo-swift &> /dev/null; then
            cargo install cargo-swift
          fi

      - name: Build shared library for bindgen
        run: |
          cd shared
          cargo build --lib
          
      - name: Cache generated types
        uses: actions/cache@v4
        id: cache-typegen
        with:
          path: |
            shared/generated
            shared/Shared
          key: typegen-${{ hashFiles('shared/src/**/*.rs', 'typegen.sh') }}-v1
          restore-keys: |
            typegen-
            
      - name: Generate Swift types and bindings
        if: steps.cache-typegen.outputs.cache-hit != 'true'
        run: |
          ./typegen.sh
          
      - name: Cache Xcode DerivedData
        uses: actions/cache@v4
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: xcode-deriveddata-${{ runner.os }}-${{ hashFiles('iOS/**/*.swift', 'iOS/**/*.plist', 'iOS/**/*.pbxproj') }}
          restore-keys: |
            xcode-deriveddata-${{ runner.os }}-
            
      - name: Cache Swift Package Manager
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/org.swift.swiftpm
          key: spm-${{ runner.os }}-${{ hashFiles('iOS/Intrada.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved') }}
          restore-keys: |
            spm-${{ runner.os }}-
            
      - name: Create Config.plist with secrets
        run: |
          cp iOS/Intrada/Config.plist.template iOS/Intrada/Config.plist
          # Replace placeholders with actual values from GitHub secrets
          sed -i '' 's|https://your-appwrite-endpoint.cloud.appwrite.io/v1|${{ secrets.APPWRITE_ENDPOINT }}|g' iOS/Intrada/Config.plist
          sed -i '' 's|your-project-id-here|${{ secrets.APPWRITE_PROJECT_ID }}|g' iOS/Intrada/Config.plist
          sed -i '' 's|your-database-id-here|${{ secrets.APPWRITE_DATABASE_ID }}|g' iOS/Intrada/Config.plist
          sed -i '' 's|your-api-key-here|${{ secrets.APPWRITE_API_KEY }}|g' iOS/Intrada/Config.plist
          
      - name: Build and test iOS app
        run: |
          cd iOS
          # Build the app
          xcodebuild \
            -project Intrada.xcodeproj \
            -scheme Intrada \
            -configuration Debug \
            -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' \
            clean build \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO
            
          # Run tests if they exist
          xcodebuild test \
            -project Intrada.xcodeproj \
            -scheme Intrada \
            -configuration Debug \
            -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            || echo "No tests found or tests failed - continuing build verification"

  # Web build job with optimized caching
  web-build:
    runs-on: ubuntu-latest
    needs: [changes, build-artifacts]
    if: needs.changes.outputs.web == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          targets: 'wasm32-unknown-unknown'

      - name: Restore build artifacts cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
            shared/target/
            web-leptos/target/
          key: ${{ needs.build-artifacts.outputs.cache-key }}
          restore-keys: |
            build-artifacts-${{ runner.os }}-v2

      - name: Cache trunk
        uses: actions/cache@v4
        id: cache-trunk
        with:
          path: |
            ~/.cargo/bin/trunk
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
          key: trunk-${{ runner.os }}-v1
          
      - name: Install Trunk
        if: steps.cache-trunk.outputs.cache-hit != 'true'
        run: cargo install trunk

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "web-leptos/package-lock.json"
          
      - name: Cache Tailwind CSS and build artifacts
        uses: actions/cache@v4
        with:
          path: |
            web-leptos/node_modules/.cache
            web-leptos/.trunk
            web-leptos/style/output.css
            web-leptos/dist
          key: tailwind-${{ runner.os }}-${{ hashFiles('web-leptos/tailwind.config.js', 'web-leptos/package-lock.json', 'web-leptos/style/input.css') }}
          restore-keys: |
            tailwind-${{ runner.os }}-

      - name: Install NPM dependencies
        run: npm ci
        working-directory: ./web-leptos

      - name: Build web app
        run: |
          cd web-leptos
          npm run build
          
      - name: Upload dist artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: ./web-leptos/dist
          retention-days: 1

  # Optimized Appwrite deployment using pre-built CLI
  appwrite-deploy:
    runs-on: ubuntu-latest
    needs: [changes, rust-checks, build-artifacts]
    if: needs.changes.outputs.appwrite == 'true' && (github.event_name == 'push' || github.event_name == 'pull_request') && needs.build-artifacts.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download CLI binary
        uses: actions/download-artifact@v4
        with:
          name: appwrite-cli
          path: ./bin
          
      - name: Make CLI executable
        run: chmod +x ./bin/appwrite_cli
          
      - name: Cache Appwrite CLI
        uses: actions/cache@v4
        id: cache-appwrite-cli
        with:
          path: ~/.npm
          key: appwrite-cli-${{ runner.os }}-5.0.0-v1
          restore-keys: |
            appwrite-cli-${{ runner.os }}-5.0.0-
            
      - name: Install Appwrite CLI
        if: steps.cache-appwrite-cli.outputs.cache-hit != 'true'
        run: |
          # Install compatible CLI version for Appwrite server 1.5.7
          npm install -g appwrite-cli@5.0.0
          # Make sure it's in PATH
          export PATH="$HOME/.local/bin:$PATH"
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          
      - name: Configure Appwrite CLI
        run: |
          # CLI is installed via npm, so it should be in npm global bin
          export PATH="$(npm bin --global):$PATH"
          echo "$(npm bin --global)" >> $GITHUB_PATH
          # Test CLI installation
          appwrite --version || echo "Appwrite CLI not found in PATH"
          
      - name: Set up Docker Buildx
        if: github.ref != 'refs/heads/main'
        uses: docker/setup-buildx-action@v3
        
      - name: Cache Docker layers
        if: github.ref != 'refs/heads/main'
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: docker-${{ runner.os }}-${{ github.sha }}
          restore-keys: |
            docker-${{ runner.os }}-
            
      - name: Deploy to development
        if: github.ref != 'refs/heads/main'
        run: |
          # Setup local Appwrite for development
          docker compose up -d
          echo "Waiting for Appwrite to be ready..."
          
          # Wait for health endpoint
          timeout 180 bash -c 'until curl -s http://localhost/health > /dev/null 2>&1; do echo "Waiting for Appwrite health..."; sleep 5; done'
          
          # Wait for API to be fully ready
          echo "Waiting for Appwrite API to be ready..."
          timeout 120 bash -c 'until curl -s http://localhost/v1/health > /dev/null 2>&1; do echo "Waiting for Appwrite API..."; sleep 5; done'
          
          # Additional wait for services to stabilize
          echo "Allowing services to stabilize..."
          sleep 10
          
          # Configure Appwrite CLI to use local instance
          export PATH="$(npm bin --global):$PATH"
          echo "Configuring Appwrite CLI..."
          
          # Wait a bit more for Appwrite to be fully ready
          echo "Additional wait for Appwrite services..."
          sleep 15
          
          # Test basic connectivity
          echo "Testing Appwrite connectivity..."
          curl -f http://localhost/v1/health || (echo "‚ùå Appwrite health check failed" && exit 1)
          
          # Configure CLI for self-signed certificates first
          echo "Setting up CLI for local development..."
          appwrite client --endpoint http://localhost/v1 --selfSigned true
          
          # Create the project using the console API first
          echo "Creating project via console API..."
          PROJECT_RESPONSE=$(curl -s -X POST "http://localhost/v1/projects" \
            -H "Content-Type: application/json" \
            -H "X-Appwrite-Project: console" \
            -d '{
              "projectId": "'$APPWRITE_PROJECT_ID'",
              "name": "Intrada Dev"
            }' 2>/dev/null || echo '{"$id":"exists"}')
          
          echo "Project response: $PROJECT_RESPONSE"
          
          # Create appwrite.json for CLI configuration
          cat > appwrite.json << 'EOF'
          {
            "projectId": "intrada-dev",
            "projectName": "Intrada Dev"
          }
          EOF
          
          # Configure the CLI client settings with the project
          appwrite client --endpoint http://localhost/v1 --projectId $APPWRITE_PROJECT_ID --selfSigned true
          
          # Initialize the project properly
          echo "Initializing project with CLI..."
          appwrite init project --projectId $APPWRITE_PROJECT_ID || echo "Project init failed"
          
          # Test CLI configuration
          echo "Testing CLI configuration..."
          appwrite projects list || echo "Projects list failed"
          
          echo "CLI configuration complete - proceeding with deployment"
          
          # Deploy schema using pre-built CLI
          echo "Deploying schema..."
          
          # Make sure the CLI tool is executable
          chmod +x ./bin/appwrite_cli
          
          # Show current directory and appwrite.json content for debugging
          echo "Current directory: $(pwd)"
          echo "Contents of appwrite.json:"
          cat appwrite.json || echo "No appwrite.json found"
          
          # Ensure PATH includes npm global bin
          export PATH="$(npm bin --global):$PATH"
          
          # Test that appwrite CLI can see the project
          echo "Testing Appwrite CLI project access..."
          appwrite projects list || echo "Cannot list projects"
          
          # Deploy using our custom CLI tool (it uses the appwrite.json config we created)
          ./bin/appwrite_cli deploy \
            --database-id $APPWRITE_DATABASE_ID \
            --database-name "$APPWRITE_DATABASE_NAME" \
            --environment development

  # Vercel deployment (preview for branches, production for main)
  vercel-deploy:
    runs-on: ubuntu-latest
    needs: [changes, web-build]
    if: needs.changes.outputs.web == 'true' && (github.event_name == 'push' || github.event_name == 'pull_request')
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'preview' }}
    env:
      VERCEL_ORG_ID: ${{ secrets.ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.PROJECT_ID }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download dist artifact
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: ./web-leptos/dist

      - name: Cache Vercel CLI
        uses: actions/cache@v4
        id: cache-vercel
        with:
          path: |
            ~/.npm
            ~/.npm-global
          key: vercel-cli-${{ runner.os }}-v2
          restore-keys: |
            vercel-cli-${{ runner.os }}-
            
      - name: Install Vercel CLI
        run: |
          npm install --global vercel@latest
          echo "$(npm bin --global)" >> $GITHUB_PATH

      - name: Deploy to Vercel
        run: |
          # Deploy only the build artifacts (dist directory)
          echo "üì¶ Deploying build artifacts only..."
          
          # Verify dist contents exist and show what we're deploying
          echo "Contents of web-leptos/dist/:"
          ls -la web-leptos/dist/
          
          # Verify we have the essential files
          if [ ! -f "web-leptos/dist/index.html" ]; then
            echo "‚ùå Error: index.html not found in dist directory"
            exit 1
          fi
          
          if [ ! -f "web-leptos/dist/vercel.json" ]; then
            echo "‚ùå Error: vercel.json not found in dist directory"
            exit 1
          fi
          
          echo "Vercel configuration:"
          cat web-leptos/dist/vercel.json
          
          # Change to the dist directory to deploy only its contents
          cd web-leptos/dist
          
          # Deploy from the dist directory directly as a static site
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            # Production deployment for main branch
            echo "Deploying to production from $(pwd)..."
            vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }}
          else
            # Preview deployment for other branches
            echo "Deploying to preview from $(pwd)..."
            vercel deploy --token=${{ secrets.VERCEL_TOKEN }}
          fi 