name: Main CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - development
        - production

env:
  CARGO_TERM_COLOR: always
  APPWRITE_PROJECT_ID: intrada-dev
  APPWRITE_DATABASE_ID: intrada_db
  APPWRITE_DATABASE_NAME: "Intrada Database"

# Prevent concurrent runs on the same branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Job to determine what changed and what needs to be built
  changes:
    runs-on: ubuntu-latest
    outputs:
      rust: ${{ steps.changes.outputs.rust }}
      ios: ${{ steps.changes.outputs.ios }}
      web: ${{ steps.changes.outputs.web }}
      appwrite: ${{ steps.changes.outputs.appwrite }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            rust:
              - 'shared/**'
              - 'infrastructure/**'
              - 'Cargo.toml'
              - 'Cargo.lock'
              - 'rust-toolchain.toml'
            ios:
              - 'iOS/**'
              - 'shared/**'
              - '.github/workflows/main-ci.yml'
            web:
              - 'web-leptos/**'
              - 'shared/**'
              - '.github/workflows/main-ci.yml'
            appwrite:
              - 'infrastructure/**'
              - 'appwrite.json'
              - 'scripts/setup-appwrite-complete.sh'

  # Unified build job that compiles everything needed
  build-artifacts:
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.rust == 'true' || needs.changes.outputs.web == 'true' || needs.changes.outputs.appwrite == 'true'
    outputs:
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          targets: 'wasm32-unknown-unknown'
          
      - name: Generate cache key
        id: cache-key
        run: |
          key="build-artifacts-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}-v2"
          echo "key=$key" >> $GITHUB_OUTPUT
          
      - name: Cache build artifacts
        uses: actions/cache@v4
        id: cache-artifacts
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
            shared/target/
            web-leptos/target/
            infrastructure/target/
          key: ${{ steps.cache-key.outputs.key }}
          restore-keys: |
            build-artifacts-${{ runner.os }}-v2
            
      - name: Build all artifacts
        if: steps.cache-artifacts.outputs.cache-hit != 'true'
        run: |
          # Fetch all dependencies first
          cargo fetch --locked
          
          # Build infrastructure CLI in release mode (for appwrite deployment)
          cd infrastructure
          cargo build --bin appwrite_cli --features cli --release
          
          # Build shared library for all targets
          cd ../shared
          cargo build --lib --release
          cargo build --lib --release --target wasm32-unknown-unknown
          
          # Build web app dependencies
          cd ../web-leptos
          cargo build --lib --release --target wasm32-unknown-unknown
          
      - name: Ensure CLI binary exists
        run: |
          if [[ ! -f "target/release/appwrite_cli" ]]; then
            echo "CLI binary not found, building it..."
            cd infrastructure
            cargo build --bin appwrite_cli --features cli --release
          else
            echo "CLI binary found at target/release/appwrite_cli"
          fi
          
      - name: Upload CLI binary
        uses: actions/upload-artifact@v4
        with:
          name: appwrite-cli
          path: target/release/appwrite_cli
          retention-days: 1

  # Basic Rust checks (formatting, clippy, tests)
  rust-checks:
    runs-on: ubuntu-latest
    needs: [changes, build-artifacts]
    if: needs.changes.outputs.rust == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
          
      - name: Setup Rust
        uses: ./.github/actions/setup-rust
          
      - name: Restore build artifacts cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
            shared/target/
            infrastructure/target/
          key: ${{ needs.build-artifacts.outputs.cache-key }}
          restore-keys: |
            build-artifacts-${{ runner.os }}-v2
            
      - name: Check code formatting
        run: cargo fmt --all -- --check
        
      - name: Run clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
        
      - name: Run tests
        run: |
          cargo test --workspace
          cd infrastructure && cargo test --features cli

  # iOS build job with optimized caching
  ios-build:
    runs-on: macos-15
    needs: [changes, build-artifacts]
    if: needs.changes.outputs.ios == 'true'
    env:
      DEVELOPER_DIR: /Applications/Xcode_16.0.app/Contents/Developer
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.0'

      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          targets: 'aarch64-apple-ios-sim,x86_64-apple-ios'
          cache-suffix: '-ios'

      - name: Cache iOS build artifacts
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            shared/target/aarch64-apple-ios-sim/
            shared/target/x86_64-apple-ios/
            shared/target/debug/
          key: ios-build-${{ runner.os }}-${{ hashFiles('**/Cargo.lock') }}-v1
          restore-keys: |
            ios-build-${{ runner.os }}-v1

      - name: Cache cargo tools
        uses: actions/cache@v4
        id: cache-cargo-tools
        with:
          path: ~/.cargo/bin
          key: cargo-tools-${{ runner.os }}-v1
          restore-keys: |
            cargo-tools-${{ runner.os }}-
            
      - name: Install cargo-swift
        if: steps.cache-cargo-tools.outputs.cache-hit != 'true'
        run: |
          if ! command -v cargo-swift &> /dev/null; then
            cargo install cargo-swift
          fi

      - name: Build shared library for bindgen
        run: |
          cd shared
          cargo build --lib
          
      - name: Cache generated types
        uses: actions/cache@v4
        id: cache-typegen
        with:
          path: |
            shared/generated
            shared/Shared
          key: typegen-${{ hashFiles('shared/src/**/*.rs', 'typegen.sh') }}-v1
          restore-keys: |
            typegen-
            
      - name: Generate Swift types and bindings
        if: steps.cache-typegen.outputs.cache-hit != 'true'
        run: |
          ./typegen.sh
          
      - name: Cache Xcode DerivedData
        uses: actions/cache@v4
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: xcode-deriveddata-${{ runner.os }}-${{ hashFiles('iOS/**/*.swift', 'iOS/**/*.plist', 'iOS/**/*.pbxproj') }}
          restore-keys: |
            xcode-deriveddata-${{ runner.os }}-
            
      - name: Cache Swift Package Manager
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/org.swift.swiftpm
          key: spm-${{ runner.os }}-${{ hashFiles('iOS/Intrada.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved') }}
          restore-keys: |
            spm-${{ runner.os }}-
            
      - name: Create Config.plist with secrets
        run: |
          cp iOS/Intrada/Config.plist.template iOS/Intrada/Config.plist
          # Replace placeholders with actual values from GitHub secrets
          sed -i '' 's|https://your-appwrite-endpoint.cloud.appwrite.io/v1|${{ secrets.APPWRITE_ENDPOINT }}|g' iOS/Intrada/Config.plist
          sed -i '' 's|your-project-id-here|${{ secrets.APPWRITE_PROJECT_ID }}|g' iOS/Intrada/Config.plist
          sed -i '' 's|your-database-id-here|${{ secrets.APPWRITE_DATABASE_ID }}|g' iOS/Intrada/Config.plist
          sed -i '' 's|your-api-key-here|${{ secrets.APPWRITE_API_KEY }}|g' iOS/Intrada/Config.plist
          
      - name: Build and test iOS app
        run: |
          cd iOS
          # Build the app
          xcodebuild \
            -project Intrada.xcodeproj \
            -scheme Intrada \
            -configuration Debug \
            -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' \
            clean build \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO
            
          # Run tests if they exist
          xcodebuild test \
            -project Intrada.xcodeproj \
            -scheme Intrada \
            -configuration Debug \
            -destination 'platform=iOS Simulator,name=iPhone 16 Pro,OS=latest' \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            || echo "No tests found or tests failed - continuing build verification"

  # Web build job with optimized caching
  web-build:
    runs-on: ubuntu-latest
    needs: [changes, build-artifacts]
    if: needs.changes.outputs.web == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          targets: 'wasm32-unknown-unknown'

      - name: Restore build artifacts cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target/
            shared/target/
            web-leptos/target/
          key: ${{ needs.build-artifacts.outputs.cache-key }}
          restore-keys: |
            build-artifacts-${{ runner.os }}-v2

      - name: Cache trunk
        uses: actions/cache@v4
        id: cache-trunk
        with:
          path: |
            ~/.cargo/bin/trunk
            ~/.cargo/.crates.toml
            ~/.cargo/.crates2.json
          key: trunk-${{ runner.os }}-v1
          
      - name: Install Trunk
        if: steps.cache-trunk.outputs.cache-hit != 'true'
        run: cargo install trunk

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: "web-leptos/package-lock.json"
          
      - name: Cache Tailwind CSS and build artifacts
        uses: actions/cache@v4
        with:
          path: |
            web-leptos/node_modules/.cache
            web-leptos/.trunk
            web-leptos/style/output.css
            web-leptos/dist
          key: tailwind-${{ runner.os }}-${{ hashFiles('web-leptos/tailwind.config.js', 'web-leptos/package-lock.json', 'web-leptos/style/input.css') }}
          restore-keys: |
            tailwind-${{ runner.os }}-

      - name: Install NPM dependencies
        run: npm ci
        working-directory: ./web-leptos

      - name: Build web app
        run: |
          cd web-leptos
          npm run build
          
      - name: Upload dist artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: ./web-leptos/dist
          retention-days: 1

  # Appwrite deployment (development for non-main branches, production for main)
  appwrite-deploy:
    runs-on: ubuntu-latest
    needs: [changes, rust-checks, build-artifacts]
    if: needs.changes.outputs.appwrite == 'true' && (github.event_name == 'push' || github.event_name == 'pull_request') && needs.build-artifacts.result == 'success'
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    env:
      # Environment-specific configuration
      APPWRITE_ENDPOINT: ${{ github.ref == 'refs/heads/main' && secrets.APPWRITE_ENDPOINT_PROD || secrets.APPWRITE_ENDPOINT_DEV }}
      APPWRITE_PROJECT_ID: ${{ github.ref == 'refs/heads/main' && secrets.APPWRITE_PROJECT_ID_PROD || secrets.APPWRITE_PROJECT_ID_DEV }}
      APPWRITE_API_KEY: ${{ github.ref == 'refs/heads/main' && secrets.APPWRITE_API_KEY_PROD || secrets.APPWRITE_API_KEY_DEV }}
      APPWRITE_DATABASE_ID: ${{ github.ref == 'refs/heads/main' && secrets.APPWRITE_DATABASE_ID_PROD || secrets.APPWRITE_DATABASE_ID_DEV }}
      APPWRITE_DATABASE_NAME: ${{ github.ref == 'refs/heads/main' && secrets.APPWRITE_DATABASE_NAME_PROD || secrets.APPWRITE_DATABASE_NAME_DEV }}
      DEPLOYMENT_ENVIRONMENT: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Download CLI binary
        uses: actions/download-artifact@v4
        with:
          name: appwrite-cli
          path: ./bin
          
      - name: Make CLI executable
        run: chmod +x ./bin/appwrite_cli
          
      - name: Cache Appwrite CLI
        uses: actions/cache@v4
        id: cache-appwrite-cli
        with:
          path: ~/.local/bin/appwrite
          key: appwrite-cli-${{ runner.os }}-latest-v1
          restore-keys: |
            appwrite-cli-${{ runner.os }}-latest-
            
      - name: Install Appwrite CLI
        if: steps.cache-appwrite-cli.outputs.cache-hit != 'true'
        run: |
          # Install latest CLI - it should be compatible with 1.5.7
          curl -sL https://appwrite.io/cli/install.sh | bash
          # Make sure it's in PATH
          export PATH="$HOME/.local/bin:$PATH"
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          
      - name: Configure Appwrite CLI
        run: |
          # CLI is installed via script, so it should be in local bin
          export PATH="$HOME/.local/bin:$PATH"
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          # Test CLI installation
          appwrite --version || echo "Appwrite CLI not found in PATH"
          
      - name: Debug environment setup
        run: |
          echo "üîç Environment Setup Debug Information:"
          echo "   - Current environment: ${{ github.environment }}"
          echo "   - GitHub ref: ${{ github.ref }}"
          echo "   - GitHub ref name: ${{ github.ref_name }}"
          echo "   - Event name: ${{ github.event_name }}"
          echo "   - Environment logic result: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}"
          echo "   - Will use secrets with suffix: ${{ github.ref == 'refs/heads/main' && '_PROD' || '_DEV' }}"
          
      - name: Validate environment configuration
        run: |
          echo "üåç Deployment Environment: $DEPLOYMENT_ENVIRONMENT"
          echo "üîó Appwrite Endpoint: $APPWRITE_ENDPOINT"
          echo "üìã Project ID: $APPWRITE_PROJECT_ID"
          echo "üóÑÔ∏è  Database ID: $APPWRITE_DATABASE_ID"
          echo "üìù Database Name: $APPWRITE_DATABASE_NAME"
          echo "üîë API Key length: ${#APPWRITE_API_KEY}"
          
          # Show which branch we're on for debugging
          echo "üìç GitHub Ref: ${{ github.ref }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          
          # Validate required environment variables are set
          MISSING_VARS=()
          
          if [ -z "$APPWRITE_ENDPOINT" ]; then
            MISSING_VARS+=("APPWRITE_ENDPOINT")
          fi
          
          if [ -z "$APPWRITE_PROJECT_ID" ]; then
            MISSING_VARS+=("APPWRITE_PROJECT_ID")
          fi
          
          if [ -z "$APPWRITE_API_KEY" ]; then
            MISSING_VARS+=("APPWRITE_API_KEY")
          fi
          
          if [ -z "$APPWRITE_DATABASE_ID" ]; then
            MISSING_VARS+=("APPWRITE_DATABASE_ID")
          fi
          
          if [ -z "$APPWRITE_DATABASE_NAME" ]; then
            MISSING_VARS+=("APPWRITE_DATABASE_NAME")
          fi
          
          if [ ${#MISSING_VARS[@]} -gt 0 ]; then
            echo "‚ùå Error: Missing required environment variables:"
            printf "   - %s\n" "${MISSING_VARS[@]}"
            echo ""
            echo "üîç Required GitHub secrets for $DEPLOYMENT_ENVIRONMENT environment:"
            if [ "$DEPLOYMENT_ENVIRONMENT" = "production" ]; then
              echo "   - APPWRITE_ENDPOINT_PROD"
              echo "   - APPWRITE_PROJECT_ID_PROD"
              echo "   - APPWRITE_API_KEY_PROD"
              echo "   - APPWRITE_DATABASE_ID_PROD"
              echo "   - APPWRITE_DATABASE_NAME_PROD"
            else
              echo "   - APPWRITE_ENDPOINT_DEV"
              echo "   - APPWRITE_PROJECT_ID_DEV"
              echo "   - APPWRITE_API_KEY_DEV"
              echo "   - APPWRITE_DATABASE_ID_DEV"
              echo "   - APPWRITE_DATABASE_NAME_DEV"
            fi
            echo ""
            echo "‚ÑπÔ∏è  Please configure these secrets in your GitHub repository settings"
            exit 1
          fi
          
          echo "‚úÖ Environment validation passed"
          
      - name: Configure and test Appwrite connection
        run: |
          echo "üîç Configuring Appwrite CLI for CI environment..."
          echo "üîó Endpoint: $APPWRITE_ENDPOINT"
          echo "üìã Project ID: $APPWRITE_PROJECT_ID"
          echo "üîë API Key length: ${#APPWRITE_API_KEY}"
          
          # Configure CLI for CI/server mode
          export PATH="$HOME/.local/bin:$PATH"
          
          # Set client configuration for CI environment
          appwrite client \
            --endpoint "$APPWRITE_ENDPOINT" \
            --project-id "$APPWRITE_PROJECT_ID" \
            --key "$APPWRITE_API_KEY"
          
          echo "‚úÖ CLI configured for CI mode"
          
          # Test project access
          echo "üîç Testing project access..."
          if appwrite projects get --project-id "$APPWRITE_PROJECT_ID"; then
            echo "‚úÖ Project access confirmed"
          else
            echo "‚ùå Cannot access project"
            echo "üîç Debugging information:"
            echo "   - Endpoint: $APPWRITE_ENDPOINT"
            echo "   - Project ID: $APPWRITE_PROJECT_ID"
            echo "   - API Key length: ${#APPWRITE_API_KEY}"
            echo "   - Current client configuration:"
            appwrite client --debug || true
            exit 1
          fi
          
      - name: Deploy schema
        run: |
          echo "üöÄ Deploying schema to $DEPLOYMENT_ENVIRONMENT environment..."
          
          # Deploy using our custom CLI tool
          ./bin/appwrite_cli deploy \
            --database-id "$APPWRITE_DATABASE_ID" \
            --database-name "$APPWRITE_DATABASE_NAME" \
            --environment "$DEPLOYMENT_ENVIRONMENT"
          
          echo "‚úÖ Schema deployment completed"
          
      - name: Verify deployment
        run: |
          echo "üîç Verifying deployment..."
          
          # Ensure PATH is set for Appwrite CLI
          export PATH="$HOME/.local/bin:$PATH"
          
          # Check if database exists
          if appwrite databases get --database-id "$APPWRITE_DATABASE_ID"; then
            echo "‚úÖ Database verified"
          else
            echo "‚ùå Database not found after deployment"
            exit 1
          fi
          
          # Check collections
          echo "üîç Checking collections..."
          if appwrite databases list-collections --database-id "$APPWRITE_DATABASE_ID"; then
            echo "‚úÖ Collections verified"
          else
            echo "‚ùå Cannot list collections"
            exit 1
          fi
          
          echo "üéâ Deployment verification completed successfully"

  # Vercel deployment (preview for branches, production for main)
  vercel-deploy:
    runs-on: ubuntu-latest
    needs: [changes, web-build]
    if: needs.changes.outputs.web == 'true' && (github.event_name == 'push' || github.event_name == 'pull_request')
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'preview' }}
    env:
      VERCEL_ORG_ID: ${{ secrets.ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.PROJECT_ID }}
    steps:
      # Only download the dist artifact - no repository checkout
      - name: Download dist artifact
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: ./dist

      - name: Cache Vercel CLI
        uses: actions/cache@v4
        id: cache-vercel
        with:
          path: |
            ~/.npm
            ~/.npm-global
          key: vercel-cli-${{ runner.os }}-v2
          restore-keys: |
            vercel-cli-${{ runner.os }}-
            
      - name: Install Vercel CLI
        run: |
          npm install --global vercel@latest
          echo "$(npm bin --global)" >> $GITHUB_PATH

      - name: Deploy to Vercel
        run: |
          # Deploy only the build artifacts (dist directory)
          echo "üì¶ Deploying build artifacts only..."
          
          # Verify dist contents exist and show what we're deploying
          echo "Contents of dist/:"
          ls -la dist/
          
          # Verify we have the essential files
          if [ ! -f "dist/index.html" ]; then
            echo "‚ùå Error: index.html not found in dist directory"
            exit 1
          fi
          
          if [ ! -f "dist/vercel.json" ]; then
            echo "‚ùå Error: vercel.json not found in dist directory"
            exit 1
          fi
          
          echo "Vercel configuration:"
          cat dist/vercel.json
          
          # Change to the dist directory to deploy only its contents
          cd dist
          
          # Deploy from the dist directory directly as a static site
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            # Production deployment for main branch
            echo "Deploying to production from $(pwd)..."
            vercel deploy --prod --token=${{ secrets.VERCEL_TOKEN }}
          else
            # Preview deployment for other branches
            echo "Deploying to preview from $(pwd)..."
            vercel deploy --token=${{ secrets.VERCEL_TOKEN }}
          fi 